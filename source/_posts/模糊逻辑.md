---
title: 模糊逻辑
author: 零度
tags:
  - Game
  - AI
date: 2021-11-29 00:14:52
categories: GameMaker
abbrlink: 32bfd856e49525fazh
---

这里是对模糊逻辑的一个初步探索，用lua实现了简单的模糊逻辑。

<!-- more -->

# 基本概念

## 定义

使电脑以一种类似人的方法去推理语言术语和规则。比如“远”、“近”、“刚好”、"适量"等概念。

## 流程

1. 建立模糊语言变量
2. 建立模糊推理系统
3. 根据模糊语言变量模糊化
4. 根据模糊规则计算后果的置信度
5. 去模糊

## 普通集合

普通集合就不说了，只要知道普通集合是具有确定性的即可。

## 模糊集合

模糊集合和普通集合不一样的是，对于同一个数值，它可能具有不同的状态。例如一个人的智商是100，那觉得他是正常人的人群约占80%，觉得他是聪明人的人群约占20%。模糊集合便能做到这一点，因此能够描述人类语言中不确定的词语。

### 隶属函数

模糊集合通过一个隶属函数来定义，这些函数可以是任意形状的，如下图所示。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/隶属函数示例.png" style="zoom:20%;" />

简单来说，隶属函数就是能使一个值部分地隶属于某个集合。就好像图中竖线那个值一部分属于集合C，一部分属于集合B。

对于隶属函数的描述，可以采用三个特殊点的方式（见下文示例一看便知）。此方法足以描述左肩函数、右肩函数和三角函数，但对于梯形函数需要四个特殊点。

隶属函数的数学符号一般可写为
$$
F_{Name\_Of\_Set}(x)
$$

### 模糊集合运算符

与运算（交集）
$$
F_{A\cap B}(x)=min\{F_{A}(x), F_{B}(x)\}
$$
或运算（并集）
$$
F_{A\cup B}(x)=max\{F_{A}(x), F_{B}(x)\}
$$
补集
$$
F_{A}(x)^{'}=1-F_{A}(x)
$$

### 限制词

很多时候我们会说一些修饰词，比如非常。这一类词语可以略微缩小和扩大隶属度的范围，也就是让标准更宽松或者更严格。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/限制词修饰.png" style="zoom:20%;" />

一般来说，更严格地情况可以用平方函数，更宽松的情况可以开根号。

## 模糊语言变量

模糊语言变量是由一个或多个模糊集合的合成，它定量地表示一种概念或一种域。比如
$$
速度=\{慢， 中等， 快\}
$$
也就是说，我们要为一个模糊语言变量创建一个或数个隶属函数。比如在“速度”这个语言变量下，我要创建“慢”、“中等”、“快”三个隶属函数。至于怎么定义慢，那根据应用背景，每个人都会有自己的理解。

## 模糊规则

在有了模糊语言变量之后，接下来便是规则。规则可以用前因后果这样的形式来描述：

如果 *前提* 那么 *后果*

这种形式很适合代码直观理解。

多个模糊规则的建立就形成了一个模糊推理系统。根据已建立的模糊推理系统，最终我们会得到一个和*后果*相关的模糊语言变量合集。此时我们需要通过去模糊化的操作让该语言变量返回一个确定的值以供比较。

## 去模糊化

去模糊化方法很多，但我只知道这几种。

### 最大值均值（MOM）

计算具有最高置信度的输出值的平均值。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/MOM.png" style="zoom:20%;" />

这种情况完全不考虑置信度低的集合，所以很多时候并不准确。

### 中心法

确定输出集合整体的中心。图就不放了。可以想象成在杠杆上寻找重心的过程。那么寻找中心就得进行离散取样，计算中心的公式如下。
$$
Center=\frac{\sum_{s=min}^{max}s*DOM(s)}{\sum_{s=min}^{max}DOM(s)}
$$

### 最大值平均（MaxAv）

对于每一个隶属函数，它都会有一个最大值。对于三角形函数来说，这个地方就是它的隶属值最大处；对于有平台的函数来说，这个地方就是隶属值最大的平台的中点。这个值就是代表这个隶属函数的值。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/MaxAv.png" style="zoom:20%;" />

图中A、B、C分别代表各自隶属函数的最大值（这里需要注意的是，并不是修剪之后的平均）。然后再对这三个隶属函数的置信度取加权平均即可。

# 示例

此处用一个武器选择作为示例。假定武器是中距离武器，发射间隔较长。

## 模糊语言变量设计

这里简单地使用AI距离目标距离和携有子弹数量来判断武器的选择。武器的选择可以用一个期望值来确定。

### 期望值模糊语言变量

使用三个隶属函数代表“不期望”、“期望”和“非常期望”。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/期望值.png" style="zoom:25%;" />

具体参数为：

1. 不期望：左肩函数（0，25，50）
2. 期望：三角函数（25，50，75）
3. 非常期望：右肩函数（50，75，100）

### 目标距离模糊语言变量

同样使用三个隶属函数表示近中远。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/距离.png" style="zoom:25%;" />

具体参数为：

1. 近：左肩函数（0，25，150）
2. 中：三角函数（25，150，300）
3. 远：右肩函数（150，300，400）

### 子弹数量模糊语言变量

同样使用三个隶属函数表示少、合适和多。

<img src="https://lingdu-picture.oss-cn-beijing.aliyuncs.com/img/子弹数量.png" style="zoom:25%;" />

具体参数为：

1. 低：左肩函数（0，0，10）
2. 合适：三角函数（0，10，30）
3. 多：右肩函数（10，30，40）

## 模糊推理系统设计

模糊推理系统的设计实际是根据经验设计相应的规则。因为我们使用的是中距离武器，所以我们倾向于中等距离使用它。由于发射间隔较长，所以子弹数少一些也能接受。

规则集如下：

1. 如果***远距离***与***子弹多***，那么***期望***
2. 如果***远距离***与***子弹中等***，那么***不期望***
3. 如果***远距离***与***子弹少***，那么***不期望***
4. 如果***中等距离***与***子弹多***，那么***非常期望***
5. 如果***中等距离***与***子弹中等***，那么***非常期望***
6. 如果***中等距离***与***子弹少***，那么***期望***
7. 如果***近距离***与***子弹多***，那么***不期望***
8. 如果***近距离***与***子弹中等***，那么***不期望***
9. 如果***近距离***与***子弹少***，那么***不期望***

自此，我们便完成了模糊推理系统的建设。下面我们就代入一个具体的值看下整个计算过程。

## 计算过程

假定目标距离为200，子弹数目是8。下列一条对应一个相应的规则。

1. 远距离：0.33，子弹多：0，期望：0（对于远距离和子弹多，子弹数目为8时，子弹多的隶属度为0。因为与运算，期望的置信度一定为0。）
2. 远距离：0.33，子弹中等：0.8，不期望：0.33
3. 远距离：0.33，子弹少：0.2，不期望：0.2
4. 中等距离：0.67，子弹多：0，非常期望：0
5. 中等距离：0.67，子弹中等：0.8，非常期望：0.67
6. 中等距离：0.67，子弹少：0.2，期望：0.2
7. 近距离：0，子弹数：**，不期望：0（8，9同）

此时可以得到模糊联想矩阵。

|          |   近距离    |       中等距离       |       远距离       |
| :------: | :---------: | :------------------: | :----------------: |
|  子弹少  | 不期望（0） |   **期望（0.2）**    | **不期望（0.2）**  |
| 子弹中等 | 不期望（0） | **非常期望（0.67）** | **不期望（0.33）** |
|  子弹多  | 不期望（0） |    非常期望（0）     |     期望（0）      |

从结果中可以发现，每一种期望值隶属函数都有多个置信度。处理多个置信度同样有不同的方法，常见的就两种。一是有界限的求和，二是最大值。此处就用最大值来处理，这样我们就能得到一个结论。

|   结论   | 置信度 |
| :------: | :----: |
|  不期望  |  0.33  |
|   期望   |  0.2   |
| 非常期望 |  0.67  |

这其实相当于对原有的期望值模糊语言变量进行修剪的过程。在去模糊化（下一步就是去模糊化）的过程中，高于置信度的将会被限制为置信度，低于置信度的仍保持不变。

## 去模糊化

现在我们来整理一下已知的内容，首先是结论（如上表所示），其次是期望值的模糊语言变量，具体参数为：

1. 不期望：左肩函数（0，25，50）-- 12.5
2. 期望：三角函数（25，50，75）-- 50
3. 非常期望：右肩函数（50，75，100）-- 87.5

最后添加的数值为最大值平均用到的代表值。

### 最大值均值

很明显，结果为5/6*100≈83.33。

### 最大值平均

$$
\frac{12.5*\frac{1}{3}+50*0.2+87.5*\frac{2}{3}}{\frac{1}{3}+0.2+\frac{2}{3}}=\frac{217.5}{3.6}≈60.42
$$

### 中心法

中心法则采用离散取值的办法，在采样点为10时可以求出结果为62。

## 事后

自此我们就给出了当前情况下选择该武器的具体期望值。那么在实际运用中，可以计算多个武器的期望值来确定AI到底使用哪一把武器。

那么除了这里，还有什么地方能用上模糊逻辑呢？

# 使用指南

项目地址：https://github.com/LingDu-zero/FuzzyLogic

## 导入必要的包

整个程序必须require的包只有一个，就是FuzzyModule。其它的例如FzAnd、FzOr、FzVery等操作数都是看需求导入。

## 创建一个模糊逻辑类

```lua
fm = FuzzyModule:new(NumSamples, Debug)
```

NumSamples参数默认为15，它是去模糊化过程中采用中心法的采样数目。

Debug参数默认为false，为true时会输出模糊化后的DOM信息。

## 建立模糊语言变量

```lua
DistToTarget = fm:CreateFLV("DistToTarget")
```

这里的返回值是一个FuzzyVariableModule类。

字符串参数用于表的存储，即table[name] = FuzzyVariableModule实例。

## 建立成员集合

```lua
Target_Close = DistToTarget:AddLeftShoulderSet("Target_Close", 0, 25, 150)
Target_Medium = DistToTarget:AddTriangularSet("Target_Medium", 25, 150, 300)
Target_Far = DistToTarget:AddRightShoulderSet("Target_Far", 150, 300, 400)
```

建立成员集合主要通过AddxxxSet方法添加隶属函数，此处一共实现了四种隶属函数，分别是AddLeftShoulderSet、AddRightShoulderSet、AddTriangularSet和AddSingletonSet。如果要添加隶属函数，可自行在FuzzySet内添加，并在FuzzyVariableModule内实现添加方法。

第一个字符串参数也是作为表的key，第二个参数表示最左边的值，第三个参数表示转折点，第三个参数表示最右边的值。详见前文对隶属函数的描述。

此处会返回一个FzSet类实例。为什么要再做一层FzSet而不是返回FuzzySet呢？在原版c++里面FzSet是一个代理类，方便拷贝自身并传递，但是它又会作为一个操作数和FzAnd这些操作一起继承FuzzyTerm这个抽象基类，所以这里还是保留了。（但是抽象类在lua里面是不是没什么意义啊。。。）

## 添加规则

```lua
fm:AddRule(FzAnd(Target_Close, Ammo_Loads), UnDesirable)
```

添加规则需要调用FuzzyModule的AddRule函数，规则由因和果构成。第一个参数就代表因，第二参数就代表果，它们都是继承自FuzzyTerm类。

## 计算具体的值

经过上面的操作，一个模糊逻辑就建立完毕了，下面就可以使用它了。

```lua
function CalculateDesirability(f, dist, ammo)
	f:Fuzzify("DistToTarget", dist)
	f:Fuzzify("AmmoStatus", ammo)
	
	return f:DeFuzzify("Desirability", f.DefuzzifyType[2])
end
```

首先肯定要对相应的“因”进行模糊化，调用FuzzyModule的Fuzzify即可。这里的第一个字符串参数表示模糊语言变量，第二个参数表示具体的值。

对所有的“因”模糊化之后就可以用DeFuzzify函数进行去模糊化。这里的第一个字符串参数表示模糊语言变量，第二个参数表示去模糊化方法。内置了两种去模糊化方法，DefuzzufyType[1]是最大值平均法（MaxAv），DefuzzufyType[2]是中心法。

## 注意事项

1. 没有做各种异常处理。。。
2. 很不完善

# 参考文献

[1]巴克兰. 游戏人工智能编程案例精粹[M]. 人民邮电出版社, 2012.